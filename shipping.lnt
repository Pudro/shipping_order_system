module shipping is

  type product is
    STEEL_BEAM, BLACHODACHOWKA, KOTWA, PLANDEKA, GWOZDZIE
    with ==, !=
  end type

  type quantity is
    quantity(i: nat)
    with get, set, ==, !=, >=, <=
  end type

  type stock is
    stock(prod: product, qty: quantity)
    with get, set
  end type

  type stock_array is
    array [0 .. 3] of stock
  end type

  channel product_in_C is
    (product)
  end channel

  channel quantity_in_C is
    (quantity)
  end channel

  channel product_C is
    (product)
  end channel

  channel quantity_C is
    (quantity)
  end channel

  channel stock_array_C is
    (stock_array)
  end channel

  channel stock_available_C is
    (bool)
  end channel

  channel order_C is
    (stock)
  end channel

  channel cancel_order_C is
    (bool)
  end channel

  channel close_order_C is
    (bool)
  end channel

  channel order_accepted_C is
    (bool)
  end channel

  channel payment_received_C is
    (bool)
  end channel

  channel order_packed_C is
    (bool)
  end channel

  channel order_shipped_C is
    (bool)
  end channel

  channel order_finalized_C is
    (bool)
  end channel

  process main[p: product_C,
               q: quantity_C,
               p_in: product_in_C,
               q_in: quantity_in_C,
               sa: stock_available_C,
               notify_customer: any,
               oa: order_accepted_C,
               pr: payment_received_C,
               op: order_packed_C,
               o: order_C,
               co: cancel_order_C,
               cancel_order: any,
               clo: close_order_C,
               close_order: any,
               packing_order: any,
               tracking_shipment: any,
               os: order_shipped_C,
               fo: order_finalized_C,
               display_stock: any] is

    var available_stock: stock_array, x: nat, y: product in
      available_stock := stock_array(stock(STEEL_BEAM, quantity(10)));
      --display_stock(available_stock[0].prod, available_stock[0].qty,
      --              available_stock[1].prod, available_stock[1].qty,
      --              available_stock[2].prod, available_stock[2].qty,
      --              available_stock[3].prod, available_stock[3].qty);

      available_stock[1] := available_stock[1].{prod -> BLACHODACHOWKA, qty -> quantity(250)};
      available_stock[2] := available_stock[2].{prod -> PLANDEKA, qty -> quantity(50)};
      available_stock[3] := available_stock[3].{prod -> KOTWA, qty -> quantity(254)};
      hide display_stock: none in
      display_stock(available_stock[0].prod, available_stock[0].qty,
                    available_stock[1].prod, available_stock[1].qty,
                    available_stock[2].prod, available_stock[2].qty,
                    available_stock[3].prod, available_stock[3].qty)
      end hide;
    --loop
    --  receiveOrder[select_product]
    --end loop
    --x := 1;
    --y := KOTWA;
    -- function for choosing goes here or something idk
      loop
      par
        o -> receiveOrder[p_in, q_in, o]
        ||
        o, sa -> checkStock[o, sa, display_stock](available_stock)
        ||
        sa, co -> notifyOutOfStock[sa, co, notify_customer]
        ||
        sa, oa -> acceptOrder[sa, oa]
        ||
        o, oa -> updateStock[o, oa](available_stock)
        ||
        co, clo, pr -> cancelOrder[co, clo, pr, cancel_order]
        ||
        clo, oa, fo -> closeOrder[clo, oa, os, fo, close_order]
        ||
        oa, pr -> makePayment[oa, pr]
        ||
        pr, fo -> finalizeOrder[pr, fo, os, packing_order, tracking_shipment](available_stock)
      end par
      end loop
      
    end var
  end process

  process updateStock[o: order_C, oa: order_accepted_C](available_stock: stock_array) is
    var order: stock, order_accepted_signal: bool in
      o(?order);
      oa(?order_accepted_signal);
      if order_accepted_signal then
        available_stock := update_stock(available_stock, order)
      end if
    end var
  end process

  process receiveOrder[p_in: product_in_C, q_in: quantity_in_C, o: order_C] is
    var x: nat, y: product, order: stock in
      -- get user order
      p_in(?y);
      q_in(?quantity(x));

      -- pass order further
      o(stock(y, quantity(x)))
    end var
  end process

  process checkStock[o: order_C, sa: stock_available_C, display_stock: any](available_stock: stock_array) is
    var order: stock, stock_available: bool in
      o(?order);

      stock_available := check_stock(available_stock, order);

      --sa(available_stock)
      sa(stock_available)
      --display_stock(order.qty)
    end var
  end process

  process acceptOrder[sa: stock_available_C, oa: order_accepted_C] is
    var stock_available: bool in 
      sa(?stock_available);
      if stock_available then
        select
          oa(true)
          []
          oa(false)
        end select
      end if
    end var
  end process

  process notifyOutOfStock[sa: stock_available_C, co: cancel_order_C, notify_customer: any] is
    var stock_available: bool in
      sa(?stock_available);
      if not(stock_available) then
        par
          co(true)
          ||
          notify_customer("Product not available")
        end par
      end if
    end var
  end process

  process makePayment[oa: order_accepted_C, pr: payment_received_C] is
    var order_accepted_signal: bool in
      oa(?order_accepted_signal);
      if order_accepted_signal then
        select
          pr(true)
          []
          pr(false)
        end select
      end if
    end var
  end process

  process finalizeOrder[pr: payment_received_C, fo: order_finalized_C, os: order_shipped_C,
                        packing_order: any, tracking_shipment: any](available_stock: stock_array) is
    var payment_received_signal, order_shipped_signal: bool in
      pr(?payment_received_signal);
      if payment_received_signal then
          par
            os ->
            packOrder[packing_order];
            shipOrder[os]
            ||
            os ->
            trackShipment[tracking_shipment];
            os(?order_shipped_signal)
          end par;
          if order_shipped_signal then
              tracking_shipment(available_stock);
              fo(true)
          end if
      end if
    end var
  end process

  process packOrder[packing_order: any] is
    packing_order
  end process

  process shipOrder[os: order_shipped_C] is
    os(true)
  end process

  process trackShipment[tracking_shipment: any] is
    tracking_shipment
  end process

  process cancelOrder[co: cancel_order_C, clo: close_order_C,
                      pr: payment_received_C, cancel_order: any] is
    var cancel_order_signal, payment_received_signal: bool in
      par
        co(?cancel_order_signal);
        if cancel_order_signal then
          cancel_order;
          clo(true)
        end if
        ||
        pr(?payment_received_signal);
        if not(payment_received_signal) then
          cancel_order;
          clo(true)
        end if
      end par
    end var 
  end process

  process closeOrder[clo: close_order_C, oa: order_accepted_C,
                     os: order_shipped_C, fo: order_finalized_C,
                     close_order: any] is
    var close_order_signal, order_accepted_signal, order_finalized_signal: bool in
      par
        clo(?close_order_signal);
        if close_order_signal then
          close_order
        end if
        ||
        oa(?order_accepted_signal);
        if not(order_accepted_signal) then
          close_order
        end if
        ||
        fo(?order_finalized_signal);
        if order_finalized_signal then
          close_order
        end if
      end par
    end var 
  end process

  function check_stock (available_stock: stock_array, order: stock): bool is
    var n: nat in
      for n := 0 while n <= 3 by n := n + 1 loop
        if available_stock[n].prod == order.prod and available_stock[n].qty >= order.qty then
          return true
        end if
      end loop;
      return false
    end var
  end function

  function update_stock (available_stock: stock_array, order: stock): stock_array is
    var n: nat in
      for n := 0 while n <= 3 by n := n + 1 loop
        if available_stock[n].prod == order.prod and available_stock[n].qty >= order.qty then
          available_stock[n] := available_stock[n].{qty -> quantity(0)}
        end if
      end loop;
      return available_stock
    end var
  end function

end module
