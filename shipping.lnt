module shipping is

  type product is
    STEEL_BEAM, BLACHODACHOWKA, KOTWA, PLANDEKA, GWOZDZIE
    with ==, !=
  end type

  type quantity is
    quantity(i: nat)
    with get, set, ==, !=, >=, <=
  end type

  type stock is
    stock(prod: product, qty: quantity)
    with get, set
  end type

  type stock_array is
    array [0 .. 3] of stock
  end type

  channel product_in_C is
    (product)
  end channel

  channel quantity_in_C is
    (quantity)
  end channel

  channel product_C is
    (product)
  end channel

  channel quantity_C is
    (quantity)
  end channel

  channel stock_array_C is
    (stock_array)
  end channel

  channel stock_available_C is
    (bool)
  end channel

  channel order_C is
    (stock)
  end channel

  channel cancel_order_C is
    (bool)
  end channel

  process main[p: product_C,
               q: quantity_C,
               p_in: product_in_C,
               q_in: quantity_in_C,
               sa: stock_available_C,
               o: order_C,
               co: cancel_order_C,
               display_stock: any] is

    var available_stock: stock_array, x: nat, y: product in
      available_stock := stock_array(stock(STEEL_BEAM, quantity(10)));
      --display_stock(available_stock[0].prod, available_stock[0].qty,
      --              available_stock[1].prod, available_stock[1].qty,
      --              available_stock[2].prod, available_stock[2].qty,
      --              available_stock[3].prod, available_stock[3].qty);

      available_stock[1] := available_stock[1].{prod -> BLACHODACHOWKA, qty -> quantity(250)};
      available_stock[2] := available_stock[2].{prod -> PLANDEKA, qty -> quantity(50)};
      available_stock[3] := available_stock[3].{prod -> KOTWA, qty -> quantity(254)};
      display_stock(available_stock[0].prod, available_stock[0].qty,
                    available_stock[1].prod, available_stock[1].qty,
                    available_stock[2].prod, available_stock[2].qty,
                    available_stock[3].prod, available_stock[3].qty);
    --loop
    --  receiveOrder[select_product]
    --end loop
    --x := 1;
    --y := KOTWA;
    -- function for choosing goes here or something idk
    par
      o -> receiveOrder[p_in, q_in, o]
      ||
      o, sa -> checkStock[o, sa, display_stock](available_stock)
      ||
      sa, co -> notifyOutOfStock[sa, co]
    end par
      
    end var
  end process

  process receiveOrder[p_in: product_in_C, q_in: quantity_in_C, o: order_C] is
    var x: nat, y: product, order: stock in
      -- get user order
      p_in(?y);
      q_in(?quantity(x));

      -- pass order further
      o(stock(y, quantity(x)))
    end var
  end process

  process checkStock[o: order_C, sa: stock_available_C, display_stock: any](in available_stock: stock_array) is
    var order: stock, stock_available: bool in
      o(?order);

      stock_available := check_stock(order, available_stock);

      --sa(available_stock)
      sa(stock_available)
      --display_stock(order.qty)
    end var
  end process

  process notifyOutOfStock[sa: stock_available_C, co: cancel_order_C] is
    var stock_available: bool in
      sa(?stock_available);
      if stock_available == false then
        co(true)
      end if
    end var
  end process

  function check_stock (in var order: stock, available_stock: stock_array): bool is
    var i: nat in
      for i := 0 while i <= 3 by i := i + 1 loop
        if available_stock[i].prod == order.prod and available_stock[i].qty >= order.qty
          then return true
        end if
      end loop;
      return false
    end var
  end function

end module
